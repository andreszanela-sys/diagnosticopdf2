<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Generador PDF</title>
<!-- jsPDF (puede ser la versión que ya usabas) -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<style>
  /* opcional: estilos internos si quieres previsualizar algo */
  body { font-family: 'Open Sans', sans-serif; font-size: 12px; color:#000; }
</style>
</head>
<body>

<script>

// ====== Helpers de formato / espaciado ======
const LHF = 1.35;                       // line-height factor global
const P_SP = 8;                         // espacio entre párrafos (pt)


function drawLabelValue(doc, label, value, x, y, wLabel=110, size=9) {
  doc.setFont("helvetica", "bold");  doc.setFontSize(size);
  doc.text(label, x, y);
  doc.setFont("helvetica", "normal");
  doc.text(value, x + wLabel, y);
  return y + size * LHF;
}

function fmtAvg(v){ return (v!=null && !isNaN(v)) ? `${Number(v).toFixed(1)} / 5` : "-"; }
function fmtROI(v){
  if (v===null || v===undefined || v==="") return "-";
  const num = Number(v);
  if (Number.isNaN(num)) return String(v);
  return `${(num*100).toFixed(0)}%`;
}

// ====== Tabla Resultados por dimensión (4 columnas) ======
// ================= TABLA CON ROI =================
function drawResultsTable(doc, {lang, x, y, w}, rows){
  // Columnas: Dimensión | Promedio | Costo oculto | ROI
  const colW = [ w*0.46, w*0.14, w*0.22, w*0.18 ];
  const HROW = 18;
  const y0   = y;

  // Encabezado
  doc.setFillColor(240,240,240);
  doc.rect(x, y, w, HROW, 'F');
  doc.setFont('helvetica','bold'); doc.setFontSize(10);

  const H = (t)=> (lang==='en'?t.en:t.es);
  const HEADS = [
    H({es:'Dimensión', en:'Dimension'}),
    H({es:'Promedio',  en:'Avg'}),
    H({es:'Costo oculto', en:'Hidden cost'}),
    H({es:'ROI (potencial)', en:'ROI (potential)'})
  ];

  let cx = x + 6, cy = y + 12;
  HEADS.forEach((h, i)=>{ doc.text(String(h), cx, cy); cx += colW[i]; });
  y += HROW;

  // Filas
  doc.setFont('helvetica','normal'); doc.setFontSize(9);
  rows.forEach(r=>{
    // líneas divisorias
    doc.setDrawColor(230); doc.line(x, y, x+w, y);

    let tx = x + 4, ty = y + 11;

    // Col 1: Dimensión (wrap)
    const nameLines = doc.splitTextToSize(r.name, colW[0]-12);
    doc.text(nameLines, tx, ty);
    const h1 = Math.max(HROW, nameLines.length*12+6);

    // Col 2: Promedio
    tx = x + colW[0] + 6;
    doc.text(`${r.avg} / 5`, tx, ty);

    // Col 3: Costo
    tx += colW[1];
    doc.text(r.costStr, tx, ty);

    // Col 4: ROI
    tx += colW[2];
    doc.text(r.roiStr, tx, ty);

    y += Math.max(h1, HROW);
  });

  // marco sutil
  doc.setDrawColor(200); doc.rect(x, y0, w, y - y0);
  return y + GAP.md;

}

// --- Espaciados estándar (pt)
const GAP = { xs: 6, sm: 12, md: 18, lg: 28, xl: 40 };
function bump(y, a = GAP.md){ return y + a; }


// === CONFIG ROI (idéntico a Velo) ===
const CONFIG_ROI = {
  recRates: { crisis: 0.70, desconectado: 0.60, transicion: 0.45, regenerativa: 0.30 },
  roiMultipleMin: 5,           // "≥5x"
  horizonte: '12–18 meses',
  currency: 'USD'
};

// === Traducción de puntaje → etiqueta de nivel (igual que en Velo) ===
function nivelConexionTexto(p, l) {
  if (p <= 2.0) return l==='en' ? 'In crisis'     : 'En crisis';
  if (p <= 3.0) return l==='en' ? 'Disconnected'  : 'Desconectado';
  if (p <= 4.0) return l==='en' ? 'In transition' : 'En transición';
  return               l==='en' ? 'Regenerative'  : 'Regenerativa';
}

// === Ratio recuperable desde score (misma lógica que recRateFromScore de Velo) ===
function recRateFromScore(score){
  if (score <= 2.0) return CONFIG_ROI.recRates.crisis;
  if (score <= 3.0) return CONFIG_ROI.recRates.desconectado;
  if (score <= 4.0) return CONFIG_ROI.recRates.transicion;
  return              CONFIG_ROI.recRates.regenerativa;
}

// === Helpers de formato/parseo seguros ===
function moneyToNumber(s){
  // "$16,800 USD" -> 16800
  if (s == null) return 0;
  const n = String(s).replace(/[^\d.,-]/g,'').replace(/,/g,'');
  return Number(n || 0);
}
function fmtMoney(n, lang){
  try { return '$' + Math.round(+n||0).toLocaleString(lang==='en'?'en-US':'es-MX') + ' ' + CONFIG_ROI.currency; }
  catch{ return '$' + Math.round(+n||0) + ' ' + CONFIG_ROI.currency; }
}

// === Interpretaciones KPI (ES/EN) ===
function interpretNivel(nivel, lang){
  const m = {
    es:{ crisis:'Riesgo muy alto (clima y foco estratégico)', desconectado:'Riesgo alto (tensión cultural)', transicion:'Riesgo medio (oportunidad de alineación)', regenerativa:'Riesgo bajo (consolidar hábitos)' },
    en:{ crisis:'Very high risk (climate & strategic focus)', disconnected:'High risk (cultural tension)', intransition:'Medium risk (alignment opportunity)', regenerative:'Low risk (consolidate habits)' }
  };
  const k = (nivel||'').toLowerCase();
  if (k.includes('crisis'))        return m[lang].crisis;
  if (k.includes('desconect')||k.includes('disconnect')) return m[lang].desconectado;
  if (k.includes('trans'))         return m[lang].transicion;
  return m[lang].regenerativa;
}
function interpretCosto(totalNum, lang){
  // Umbrales orientativos; ajusta si usas otra moneda
  if (totalNum >= 100000) return (lang==='en'?'High annual leakage':'Fuga anual alta');
  if (totalNum >= 50000)  return (lang==='en'?'Moderate–high leakage':'Fuga moderada–alta');
  if (totalNum > 0)       return (lang==='en'?'Moderate leakage':'Fuga moderada');
  return (lang==='en'?'No leakage':'Sin fuga');
}
function interpretROI(recNum, lang){
  if (recNum <= 0) return (lang==='en'?'No recoverable potential detected':'Sin potencial recuperable detectado');
  return (lang==='en'
    ? 'Recoverable in ~12–18 months if prioritized'
    : 'Recuperable en ~12–18 meses si se prioriza');
}


// === Interpretaciones KPI (ES/EN) ===
function interpretNivel(nivel, lang){
  const m = {
    es:{ crisis:'Riesgo muy alto (clima y foco estratégico)',
         desconectado:'Riesgo alto (tensión cultural)',
         transicion:'Riesgo medio (oportunidad de alineación)',
         regenerativa:'Riesgo bajo (consolidar hábitos)' },
    en:{ crisis:'Very high risk (climate & strategic focus)',
         desconectado:'High risk (cultural tension)',
         transicion:'Medium risk (alignment opportunity)',
         regenerativa:'Low risk (consolidate habits)' }
  };
  const k = (nivel||'').toLowerCase();
  if (k.includes('crisis'))        return m[lang].crisis;
  if (k.includes('desconect')||k.includes('disconnect')) return m[lang].desconectado;
  if (k.includes('trans'))         return m[lang].transicion;
  return m[lang].regenerativa;
}

function interpretPromedio(prom, lang){
  const p = Number(prom||0);
  if (p <= 2.0) return (lang==='en'?'High disconnection — immediate containment':'Desconexión alta — contención inmediata');
  if (p <= 3.0) return (lang==='en'?'Medium disconnection — prioritize 2–3 areas':'Desconexión media — priorizar 2–3 áreas');
  if (p <= 4.0) return (lang==='en'?'Moderate connection — consolidate key habits':'Conexión moderada — consolidar hábitos clave');
  return (lang==='en'?'Solid connection — maintain cadence & metrics':'Conexión sólida — mantener cadencia y métricas');
}

function interpretCosto(totalNum, lang){
  if (totalNum >= 100000) return (lang==='en'?'High annual leakage':'Fuga anual alta');
  if (totalNum >= 50000)  return (lang==='en'?'Moderate–high leakage':'Fuga moderada–alta');
  if (totalNum > 0)       return (lang==='en'?'Moderate leakage':'Fuga moderada');
  return (lang==='en'?'No leakage':'Sin fuga');
}

function interpretROI(recNum, lang){
  if (recNum <= 0) return (lang==='en'?'No recoverable potential detected':'Sin potencial recuperable detectado');
  return (lang==='en'
    ? 'Recoverable in ~12–18 months if prioritized'
    : 'Recuperable en ~12–18 meses si se prioriza');
}

// === Bloque “Resumen ejecutivo” (Indicador | Valor | Interpretación) ===
function drawExecutiveSummary(doc, {x, y, w, lang, nivelGeneral, promedioGeneral, costoTotalStr, recTotalNum}){
  const HROW = 20, PAD = 8;
  const cols = [ w*0.30, w*0.28, w*0.42 ];
  const y0 = y;

  // Encabezado
  doc.setFillColor(240,240,240);
  doc.roundedRect(x, y, w, HROW, 6, 6, 'F');
  doc.setFont('helvetica','bold'); doc.setFontSize(11);
  const HEADS = (lang==='en' ? ['Indicator','Value','Interpretation']
                              : ['Indicador','Valor','Interpretación']);
  let cx = x + PAD, cy = y + 13;
  HEADS.forEach((h,i)=>{ doc.text(h, cx, cy); cx += cols[i]; });
  y += HROW;

  // Datos
  const costoNum = moneyToNumber(costoTotalStr);
  const filas = [
    [(lang==='en'?'General level':'Nivel general'), nivelGeneral, interpretNivel(nivelGeneral, lang)],
    [(lang==='en'?'Overall score':'Promedio general'), `${Number(promedioGeneral||0).toFixed(2)} / 5`, interpretPromedio(promedioGeneral, lang)],
    [(lang==='en'?'Total hidden cost':'Costo oculto total'), costoTotalStr, interpretCosto(costoNum, lang)],
    [(lang==='en'?'Recoverable (potential)':'Recuperable (potencial)'), fmtMoney(recTotalNum, lang), interpretROI(recTotalNum, lang)],
  ];

  // Filas
  filas.forEach(row=>{
    doc.setDrawColor(230); doc.line(x, y, x+w, y);
    // col 1 (label)
    let tx = x + PAD, ty = y + 13;
    doc.setFont('helvetica','bold'); doc.setFontSize(10); doc.text(row[0], tx, ty);
    // col 2 (valor)
    tx += cols[0]; doc.setFont('helvetica','normal'); doc.setFontSize(10); doc.text(row[1], tx, ty);
    // col 3 (interpretación wrap)
    tx += cols[1];
    const wrap = doc.splitTextToSize(String(row[2]), cols[2]-PAD);
    doc.setFontSize(10.5);
    doc.text(wrap, tx, ty);
    const h = Math.max(HROW, 14 * wrap.length + 6);
    y += h;
  });

  // Marco
  doc.setDrawColor(200); doc.roundedRect(x, y0, w, y - y0, 6, 6);
  return y + GAP.lg;
}




// === Párrafos con buen interlineado/espaciado ===

function drawParagraph(doc, text, x, y, maxW, font='helvetica', style='normal', size=10.5, lineH=16, spaceAfter=GAP.md){
  doc.setFont(font, style); doc.setFontSize(size);
  const lines = doc.splitTextToSize(String(text||''), maxW);
  doc.text(lines, x, y);
  return y + lines.length*lineH + spaceAfter;
}


// Helper: etiqueta en bold + texto normal con salto de línea correcto
function drawBoldLabelThenText(doc, label, text, x, y, maxW, gap = 6, size = 10, lineH = 12) {
  doc.setFont('helvetica','bold');  doc.setFontSize(size);
  const labelW = doc.getTextWidth(label);

  // Si la etiqueta cabe y deja espacio para texto en la misma línea
  const firstLineW = Math.max(0, maxW - labelW - gap);

  // Partimos el texto normal para la primera línea (resto va abajo)
  doc.setFont('helvetica','normal');
  const firstSlice = doc.splitTextToSize(text, firstLineW);
  const firstLineText = firstSlice.shift() || '';

  // Dibuja etiqueta + primer pedazo en la misma línea
  doc.setFont('helvetica','bold');
  doc.text(label, x, y);
  doc.setFont('helvetica','normal');
  doc.text(firstLineText, x + labelW + gap, y);

  // Dibuja el resto del texto, línea por línea, debajo
  let yy = y + lineH;
  firstSlice.forEach(line => {
    doc.text(line, x, yy);
    yy += lineH;
  });

  return yy; // devuelve el siguiente y disponible
}


// ——— Normaliza el texto que viene del HTML (quita NBSPs y espacios finos) ———
// Quita NBSP, espacios finos y también "letra espacio letra espacio..."
function normalizeText(s){
  if (!s) return '';
  // 1) limpieza básica
  let t = String(s)
    .replace(/[\u00A0\u2000-\u200B]/g, ' ') // NBSP y espacios finos → espacio normal
    .replace(/[ \t]+\n/g, '\n')
    .replace(/\n[ \t]+/g, '\n')
    .replace(/[ \t]{2,}/g, ' ')
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  // 2) des-kerning: colapsa secuencias "L e t r a s" → "Letras"
  //    Toma grupos de (letra + espacio) repetidos y elimina los espacios internos.
  t = t.replace(/((?:[A-Za-zÁÉÍÓÚÜÑáéíóúüñ]\s){2,}[A-Za-zÁÉÍÓÚÜÑáéíóúüñ])/g,
                m => m.replace(/\s/g, ''));

  // 3) versión con soporte Unicode amplio (por si hay otros caracteres)
  t = t.replace(/((?:\p{L}\s){2,}\p{L})/gu, m => m.replace(/\s/g, ''));

  return t;
}


// ——— Dibuja texto largo con salto de página automático ———
// Usa el mismo ancho (maxW) que ya usas en la página 1 (520)
function drawLongTextPaged(doc, text, x, y, maxW, opts = {}){
  const {
    font = 'helvetica',
    style = 'normal',
    size = 10.5,
    lineH = 14,
    spaceAfter = 0,
    topMargin = 40,      // M_TOP
    bottomMargin = 60,   // pie de página
  } = opts;

  const pageH = doc.internal.pageSize.getHeight();
  const yLimit = pageH - bottomMargin;

  doc.setFont(font, style);
  doc.setFontSize(size);

  // Partimos en párrafos por línea en blanco
  const paragraphs = String(text).split(/\n\s*\n/);

  for (const p of paragraphs){
    const lines = doc.splitTextToSize(p, maxW);
    for (const line of lines){
      if (y > yLimit){
        doc.addPage();
        y = topMargin;
        doc.setFont(font, style);
        doc.setFontSize(size);
      }
      doc.text(line, x, y);
      y += lineH;
    }
    y += spaceAfter; // espacio entre párrafos
  }
  return y;
}




// 1. Avisar a Wix "ya estoy listo"
window.parent.postMessage({ type: 'ready' }, "*");

// 2. Escuchar datos desde Wix
window.addEventListener('message', async (event) => {
  const data = event.data;
  if (!data) return;

  // ignorar mensajes tipo "ready" que tú mismo mandas
  if (data.type === 'ready') return;

  // sólo reaccionar a data válidos del diagnóstico
  if (data.type === 'datosInforme') {
    await generarPDFyDescargar(data);

    // Avisar de éxito de generación a Wix
    window.parent.postMessage({ type:'pdf-ok' }, '*');
  }
});





async function generarPDFyDescargar(data){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({
    unit: 'pt',   // puntos
    format: 'letter' // o 'a4', según tu pdf original
  });

  // Margenes básicos
  const M_LEFT = 40;
  const M_TOP  = 40;
  let y = M_TOP;

  // ============ PORTADA / PÁGINA 1 ============

  // Branding arriba derecha
  doc.setFont('helvetica','normal');
  doc.setFontSize(8);
  doc.text('Innovación Regenerativa | Informe diagnóstico', 400, y);
  y = bump(y, GAP.lg);       

  // Título
  doc.setFontSize(16);
  doc.setFont('helvetica','bold');
  doc.text(
    data.idioma === 'en'
      ? 'ORGANIZATIONAL DIAGNOSTIC REPORT'
      : 'INFORME DIAGNÓSTICO ORGANIZACIONAL',
    M_LEFT,
    y
  );
  y = bump(y, GAP.lg);       


  // Subtítulo institucional
    doc.setFont('helvetica','bold');
    doc.setFontSize(14);
    doc.text('Innovación Regenerativa', M_LEFT, y);
   y = bump(y, GAP.md);       // antes y += 20


  // Subtítulo
  doc.setFontSize(11);
  doc.setFont('helvetica','normal');
  y += 4;
   doc.text(
    splitLines(
      doc,
      data.idioma === 'en'
        ? 'A starting point to align purpose, energy, and outcomes in your organization'
        : 'Un punto de partida para alinear propósito, energía y resultados en tu organización',
      520
    ),
    M_LEFT,
    y
  );
 y = bump(y, GAP.lg);


  // Bloque de datos del usuario/empresa

doc.setFontSize(10.5); // un poco más grande
const labelFont = 'helvetica';
const valueFont = 'helvetica';

// Línea 1: Nombre + Empresa
doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Name:' : 'Nombre:', M_LEFT, y);
doc.setFont(valueFont, 'normal');
doc.text(`${data.nombre} ${data.apellido}`, M_LEFT + 55, y);

doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Organization:' : 'Empresa:', M_LEFT + 220, y);
doc.setFont(valueFont, 'normal');
doc.text(data.empresa, M_LEFT + 300, y);
y = bump(y, GAP.lg);

// Línea 2: Puesto + País
doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Role:' : 'Puesto:', M_LEFT, y);
doc.setFont(valueFont, 'normal');
doc.text(data.puesto, M_LEFT + 45, y);

doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Country:' : 'País:', M_LEFT + 220, y);
doc.setFont(valueFont, 'normal');
doc.text(data.pais || '', M_LEFT + 260, y);
y = bump(y, GAP.lg);

// Línea 3: Fecha
doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Date:' : 'Fecha:', M_LEFT, y);
doc.setFont(valueFont, 'normal');
doc.text(data.fecha, M_LEFT + 40, y);
y = bump(y, GAP.lg);



  // Frase inspiradora
  doc.setFont('helvetica','italic');
  doc.setFontSize(12);
  const frase = (data.idioma === 'en')
    ? 'We cannot impose regeneration; we can only create the conditions for it to emerge.'
    : 'No podemos imponer la regeneración, solo podemos crear las condiciones para que emerja.';
  y = drawParagraph(doc, `"${frase}"`, M_LEFT, y, 520, "helvetica", "italic", 9.5, 12, 0);
  
  doc.setFont('helvetica','normal');
  doc.setFontSize(11);
  doc.text('Regenesis Group', M_LEFT, y + 8);
  y = bump(y, GAP.xl);


  // Bloque estado general
  doc.setFont('helvetica','bold');
  doc.setFontSize(12);
  doc.text(
    data.idioma === 'en'
      ? 'Organizational status'
      : 'Nivel general organizacional',
    M_LEFT, y
  );
  y = bump(y, GAP.md);


  

  // Insight / lectura humana
    doc.setFont('helvetica','normal');
    doc.setFontSize(11); // antes era 9
    const insight = normalizeText(data.insightNivel || '');
    const insightLines = splitLines(doc, insight, 520);
    y = drawParagraph(doc, insight, M_LEFT, y, 520, 'helvetica', 'normal', 11, 16, GAP.sm);



    // ---- Caja gris de MÉTRICAS (Promedio, Nivel, Costo total, ROI/Recuperable) ----
    const lang = data.idioma === 'en' ? 'en' : 'es';

    // Si aún no tienes “rows” construidas aquí, calcula el recuperable total a partir de las áreas:
    const NOMBRES_ES = { proposito:'Propósito y estrategia', liderazgo:'Liderazgo y gobernanza', cultura:'Cultura y bienestar', aprendizaje:'Aprendizaje e innovación', procesos:'Procesos y tecnología', sostenibilidad:'Sostenibilidad e impacto' };
    const NOMBRES_EN = { proposito:'Purpose & Strategy', leadership:'Leadership & Governance', cultura:'Culture & Wellbeing', aprendizaje:'Learning & Innovation', procesos:'Processes & Technology', sostenibilidad:'Sustainability & Impact' };

    // Calcula recuperable total (ya lo tenías)
    let recuperableTotalN = 0;
    (data.areasDetalle || []).forEach(a => {
    const avg = Number(a.promedio || 0);
    const costN = moneyToNumber(a.costoUSD);
    const rate  = recRateFromScore(avg);
    recuperableTotalN += Math.round(costN * rate);
    });

// ===== Resumen ejecutivo con interpretación (antes de "Nivel general organizacional") =====

// Recuperable total (mismo cálculo que usas después)
    let recTotalNum = 0;
    (data.areasDetalle || []).forEach(a=>{
    const avg  = Number(a.promedio || 0);
    const cost = moneyToNumber(a.costoUSD);
    recTotalNum += Math.round(cost * recRateFromScore(avg));
    });

    // Dibuja el bloque
    y = drawExecutiveSummary(doc, {
    x: M_LEFT - 4,
    y,
    w: 520,
    lang: (data.idioma === 'en' ? 'en' : 'es'),
    nivelGeneral: data.nivelGeneral,
    promedioGeneral: data.promedioGeneral,   // <<—— NUEVO
    costoTotalStr: data.costoTotalUSD,
    recTotalNum
    });
   y = bump(y, GAP.xs);

    const recoLabel = (data.idioma === 'en') ? 'Key recommendation:' : 'Recomendación clave:';
    const recoBody  = (data.idioma === 'en')
    ? ' Focus leadership attention on the 2–3 lowest scoring areas and link fixes to strategic purpose. Disconnection is expensive — and reversible.'
    : ' Poner en agenda de liderazgo las 2–3 áreas con menor puntaje y vincular su mejora al propósito estratégico. La desconexión es costosa, pero reversible.';

    // Título “Recomendación” no hace falta; imprime directamente la línea compuesta:
    doc.setFontSize(10);
    y = drawBoldLabelThenText(doc, recoLabel, recoBody, M_LEFT, y, 520, 6, 10, 12);
   y = bump(y, GAP.md);


  // Tabla resumen por dimensión
  doc.setFont('helvetica','bold');
  doc.setFontSize(11);
  doc.text(
    data.idioma==='en'
      ? 'Results by dimension'
      : 'Resultados por dimensión',
    M_LEFT,
    y
  );
  y = bump(y, GAP.md);


  // ===== Construcción de filas para la tabla (usa data.areasDetalle ya enviado desde Velo) =====
   

    // Normalizamos filas con ROI
    const rows = (data.areasDetalle || []).map(a => {
    const label = (lang==='en' ? NOMBRES_EN[a.areaKey] : NOMBRES_ES[a.areaKey]) || a.areaKey;
    const avg   = Number(a.promedio || 0);
    const costN = moneyToNumber(a.costoUSD);             // número
    const rate  = recRateFromScore(avg);                 // 0.70 / 0.60 / 0.45 / 0.30
    const rec   = Math.round(costN * rate);              // recuperable potencial
    const inv   = Math.max(1, Math.round(rec / (CONFIG_ROI.roiMultipleMin||5))); // inversión estimada p/≥5x
    const roiX  = (rec>0 && inv>0) ? (rec/inv) : CONFIG_ROI.roiMultipleMin;

    return {
        name: label,
        avg: avg.toFixed(1),
        costStr: fmtMoney(costN, lang),                // "$16,800 USD"
        roiStr: fmtMoney(rec, lang)    // solo el monto recuperable potencial
        // si prefieres explicitar inversión: `${fmtMoney(rec, lang)} (inv. ~${fmtMoney(inv, lang)} → ≥${CONFIG_ROI.roiMultipleMin}x)`
    };
    });

    // Dibujar tabla
    y = drawResultsTable(doc, { lang, x: M_LEFT, y, w: 520 }, rows);

    // Línea “Costo oculto estimado” (abajo de la tabla)
    const totalLinea = (
    lang==='en'
        ? `Estimated hidden cost: ${data.costoTotalUSD} per year.`
        : `Costo oculto estimado: ${data.costoTotalUSD} al año.`
    );
    doc.setFont('helvetica','bold'); doc.setFontSize(10);
    y = drawParagraph(doc, totalLinea, M_LEFT, y, 520, 'helvetica', 'bold', 10, 12, 3);
    y = bump(y, GAP.xs);



    const recLinea = (
    lang==='en'
        ? `Recoverable (potential): ${fmtMoney(recuperableTotalN, lang)}.`
        : `Recuperable (potencial): ${fmtMoney(recuperableTotalN, lang)}.`
    );
    doc.setFont('helvetica','bold'); doc.setFontSize(10);
    y = drawParagraph(doc, recLinea, M_LEFT, y, 520, 'helvetica', 'bold', 10, 12, 8);
    y = bump(y, GAP.sm);



  // Footer de página
  const pageH = doc.internal.pageSize.getHeight();  // obtiene la altura total del PDF
    doc.setFontSize(8);
    doc.setFont('helvetica','normal');
    doc.text(
    data.idioma==='en' ? 'Page 1' : 'Página 1',
    520,           // posición X (derecha)
    pageH - 32     // posición Y (32pt desde el borde inferior)
    );




  // ============ PÁGINA 2: Retos / Fortalezas / Acciones clave ============
  doc.addPage();
  y = M_TOP;

  doc.setFont('helvetica','bold');
  doc.setFontSize(12);
  doc.text(
    data.idioma==='en'
      ? 'Priority tensions and opportunities'
      : 'Tensiones prioritarias y oportunidades',
    M_LEFT, y
  );
  y+=20;


    // ——— Resumen largo con paginado y limpieza de espacios ———
    doc.setCharSpace && doc.setCharSpace(0); // seguridad: 0 pt entre caracteres
    const resumenLimpio = normalizeText( limpiarHTML(data.analisisNivel) );

    // título ya lo dejaste puesto arriba; ahora el cuerpo:
    y = drawLongTextPaged(doc, resumenLimpio, M_LEFT, y, 520, {
    font: 'helvetica',
    style: 'normal',
    size: 10.5,     // sube un poco para legibilidad
    lineH: 16,      // interlínea cómoda
    spaceAfter: 8,  // separación entre párrafos
    topMargin: M_TOP,
    bottomMargin: 60
    });


  // El campo analisisNivel es la narrativa larga que tú armaste (parts.htmlFull),
  // que incluye retos prioritarios, fortalezas, % de costo, recomendación.
  // Lo vamos a volcar aquí como texto multilinea:
  /*doc.setFont('helvetica','normal');
  doc.setFontSize(9);
  const analisisLines = splitLines(doc, limpiarHTML(data.analisisNivel), 520);
  // Vamos dibujando línea por línea y saltando de página si se llena
  for (let i=0; i<analisisLines.length; i++){
    if (y > 760){
      doc.addPage();
      y = M_TOP;
      doc.setFont('helvetica','normal');
      doc.setFontSize(9);
    }
    doc.text(analisisLines[i], M_LEFT, y);
    y+=12;
  }*/

  // descarga
  const fileName = generarNombreArchivo(data);
  doc.save(fileName);
}

// Helpers para formatear texto:
function splitLines(doc, text, maxWidth){
  if (!text) return [''];
  // jsPDF 2.5: splitTextToSize
  return doc.splitTextToSize(String(text), maxWidth);
}

function limpiarHTML(htmlString){
  if (!htmlString) return '';
  // quita etiquetas básicas <p>, <strong>, etc.
  return String(htmlString)
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n\n')
    .replace(/<[^>]+>/g, '')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

// Genera nombre de archivo final
function generarNombreArchivo(data){
  const nom   = (data.nombre  || '').trim().replace(/\s+/g,'_');
  const emp   = (data.empresa || '').trim().replace(/\s+/g,'_');
  const fecha = (data.fecha   || '').replace(/[^\d-]/g,'_');
  return `Diagnostico_${nom}_${emp}_${fecha}.pdf`;
}
</script>
</body>
</html>