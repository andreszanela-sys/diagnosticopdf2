<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Generador PDF</title>
<!-- jsPDF (puede ser la versi√≥n que ya usabas) -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<style>
  /* opcional: estilos internos si quieres previsualizar algo */
  body { font-family: 'Open Sans', sans-serif; font-size: 12px; color:#000; }
</style>
</head>
<body>

<script>

// ====== Helpers de formato / espaciado ======
const LHF = 1.35;                       // line-height factor global
const P_SP = 8;                         // espacio entre p√°rrafos (pt)

// Carga una imagen (URL http/https o dataURL) y la devuelve como {dataURL, w, h}
function loadImg(url){
  return new Promise((resolve, reject)=>{
    if (!url) return resolve(null);

    const img = new Image();
    // permite CORS si tu logo viene de otro dominio con headers adecuados
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      // Si ya es dataURL no hace falta canvas, pero esto lo unifica
      const canvas = document.createElement('canvas');
      canvas.width  = img.naturalWidth || img.width;
      canvas.height = img.naturalHeight || img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      resolve({ dataURL: canvas.toDataURL('image/png'), w: canvas.width, h: canvas.height });
    };
    img.onerror = reject;
    img.src = url;
  });
}

// Dibuja el logo en la esquina superior derecha. Devuelve la altura dibujada.
async function drawLogoTopRight(doc, url, { top=40, right=40, maxW=65, maxH=65 } = {}){
  const im = await loadImg(url);
  if (!im) return 0;

  const pageW = doc.internal.pageSize.getWidth();

  const sW = maxW / (im.w || maxW);
  const sH = maxH / (im.h || maxH);
  const scale = Math.min(sW, sH, 1);               // respeta ambos l√≠mites
  const w = Math.round((im.w || maxW) * scale);
  const h = Math.round((im.h || maxW*0.4) * scale);

  /*const targetW = Math.min(maxW, im.w || maxW);
  const targetH = im.w && im.h ? Math.round(targetW * (im.h / im.w)) : Math.round(targetW * 0.4);*/
  const x = pageW - right - w;
  const y = top;

  // usa PNG (seguro) ‚Äî jsPDF detecta a partir del dataURL
  doc.addImage(im.dataURL, 'PNG', x, y, w, h);
  return h;
}



function drawLabelValue(doc, label, value, x, y, wLabel=110, size=9) {
  doc.setFont("helvetica", "bold");  doc.setFontSize(size);
  doc.text(label, x, y);
  doc.setFont("helvetica", "normal");
  doc.text(value, x + wLabel, y);
  return y + size * LHF;
}

function fmtAvg(v){ return (v!=null && !isNaN(v)) ? `${Number(v).toFixed(1)} / 5` : "-"; }
function fmtROI(v){
  if (v===null || v===undefined || v==="") return "-";
  const num = Number(v);
  if (Number.isNaN(num)) return String(v);
  return `${(num*100).toFixed(0)}%`;
}

// ====== Tabla Resultados por dimensi√≥n (4 columnas) ======
// ================= TABLA CON ROI =================
function drawResultsTable(doc, {lang, x, y, w}, rows){
  // Columnas: Dimensi√≥n | Promedio | Costo oculto | ROI
  const colW = [ w*0.46, w*0.14, w*0.22, w*0.18 ];
  const HROW = 18;
  const y0   = y;

  // Encabezado
  doc.setFillColor(240,240,240);
  doc.rect(x, y, w, HROW, 'F');
  doc.setFont('helvetica','bold'); doc.setFontSize(10);

  const H = (t)=> (lang==='en'?t.en:t.es);
  const HEADS = [
    H({es:'Dimensi√≥n', en:'Dimension'}),
    H({es:'Promedio',  en:'Avg'}),
    H({es:'Costo oculto', en:'Hidden cost'}),
    H({es:'ROI (potencial)', en:'ROI (potential)'})
  ];

  let cx = x + 6, cy = y + 12;
  HEADS.forEach((h, i)=>{ doc.text(String(h), cx, cy); cx += colW[i]; });
  y += HROW;

  // Filas
  doc.setFont('helvetica','normal'); doc.setFontSize(9);
  rows.forEach(r=>{
    // l√≠neas divisorias
    if (!r || (!r.name && !r.avg && !r.costStr && !r.roiStr)) return;
    doc.setDrawColor(230); doc.line(x, y, x+w, y);

    let tx = x + 4, ty = y + 11;

    // Col 1: Dimensi√≥n (wrap)
    const nameLines = doc.splitTextToSize(r.name, colW[0]-12);
    doc.text(nameLines, tx, ty);
    const h1 = Math.max(HROW, nameLines.length*12+6);

    // Col 2: Promedio
    tx = x + colW[0] + 6;
    doc.text(fmtAvg(r.avg), tx, ty);

    //doc.text(`${r.avg} / 5`, tx, ty);

    // Col 3: Costo
    tx += colW[1];
    doc.text(r.costStr, tx, ty);

    // Col 4: ROI
    tx += colW[2];
    doc.text(r.roiStr, tx, ty);

    y += Math.max(h1, HROW);
  });

  // marco sutil
  doc.setDrawColor(200); doc.rect(x, y0, w, y - y0);
  return y + GAP.md;

}

// --- Espaciados est√°ndar (pt)
const GAP = { xs: 6, sm: 12, md: 18, lg: 25, xl: 38 };
function bump(y, a = GAP.md){ return y + a; }


// === CONFIG ROI (id√©ntico a Velo) ===
const CONFIG_ROI = {
  recRates: { crisis: 0.70, desconectado: 0.60, transicion: 0.45, regenerativa: 0.30 },
  roiMultipleMin: 5,           // "‚â•5x"
  horizonte: '12‚Äì18 meses',
  currency: 'USD'
};

// === Traducci√≥n de puntaje ‚Üí etiqueta de nivel (igual que en Velo) ===
function nivelConexionTexto(p, l) {
  if (p <= 2.0) return l==='en' ? 'In crisis'     : 'En crisis';
  if (p <= 3.0) return l==='en' ? 'Disconnected'  : 'Desconectado';
  if (p <= 4.0) return l==='en' ? 'In transition' : 'En transici√≥n';
  return               l==='en' ? 'Regenerative'  : 'Regenerativa';
}

// === Ratio recuperable desde score (misma l√≥gica que recRateFromScore de Velo) ===
function recRateFromScore(score){
  if (score <= 2.0) return CONFIG_ROI.recRates.crisis;
  if (score <= 3.0) return CONFIG_ROI.recRates.desconectado;
  if (score <= 4.0) return CONFIG_ROI.recRates.transicion;
  return              CONFIG_ROI.recRates.regenerativa;
}

// === Helpers de formato/parseo seguros ===
function moneyToNumber(s){
  // "$16,800 USD" -> 16800
  if (s == null) return 0;
  const n = String(s).replace(/[^\d.,-]/g,'').replace(/,/g,'');
  return Number(n || 0);
}
function fmtMoney(n, lang){
  try { return '$' + Math.round(+n||0).toLocaleString(lang==='en'?'en-US':'es-MX') + ' ' + CONFIG_ROI.currency; }
  catch{ return '$' + Math.round(+n||0) + ' ' + CONFIG_ROI.currency; }
}

// === Interpretaciones KPI (ES/EN) ===
/*function interpretNivel(nivel, lang){
  const m = {
    es:{ crisis:'Riesgo muy alto (clima y foco estrat√©gico)', desconectado:'Riesgo alto (tensi√≥n cultural)', transicion:'Riesgo medio (oportunidad de alineaci√≥n)', regenerativa:'Riesgo bajo (consolidar h√°bitos)' },
    en:{ crisis:'Very high risk (climate & strategic focus)', disconnected:'High risk (cultural tension)', intransition:'Medium risk (alignment opportunity)', regenerative:'Low risk (consolidate habits)' }
  };
  const k = (nivel||'').toLowerCase();
  if (k.includes('crisis'))        return m[lang].crisis;
  if (k.includes('desconect')||k.includes('disconnect')) return m[lang].desconectado;
  if (k.includes('trans'))         return m[lang].transicion;
  return m[lang].regenerativa;
}
function interpretCosto(totalNum, lang){
  // Umbrales orientativos; ajusta si usas otra moneda
  if (totalNum >= 100000) return (lang==='en'?'High annual leakage':'Fuga anual alta');
  if (totalNum >= 50000)  return (lang==='en'?'Moderate‚Äìhigh leakage':'Fuga moderada‚Äìalta');
  if (totalNum > 0)       return (lang==='en'?'Moderate leakage':'Fuga moderada');
  return (lang==='en'?'No leakage':'Sin fuga');
}
function interpretROI(recNum, lang){
  if (recNum <= 0) return (lang==='en'?'No recoverable potential detected':'Sin potencial recuperable detectado');
  return (lang==='en'
    ? 'Recoverable in ~12‚Äì18 months if prioritized'
    : 'Recuperable en ~12‚Äì18 meses si se prioriza');
}*/


// === Interpretaciones KPI (ES/EN) ===
function interpretNivel(nivel, lang){
  const m = {
    es:{ crisis:'Riesgo muy alto (clima y foco estrat√©gico)',
         desconectado:'Riesgo alto (tensi√≥n cultural)',
         transicion:'Riesgo medio (oportunidad de alineaci√≥n)',
         regenerativa:'Riesgo bajo (consolidar h√°bitos)' },
    en:{ crisis:'Very high risk (climate & strategic focus)',
         desconectado:'High risk (cultural tension)',
         transicion:'Medium risk (alignment opportunity)',
         regenerativa:'Low risk (consolidate habits)' }
  };
  const k = (nivel||'').toLowerCase();
  if (k.includes('crisis'))        return m[lang].crisis;
  if (k.includes('desconect')||k.includes('disconnect')) return m[lang].desconectado;
  if (k.includes('trans'))         return m[lang].transicion;
  return m[lang].regenerativa;
}

function interpretPromedio(prom, lang){
  const p = Number(prom||0);
  if (p <= 2.0) return (lang==='en'?'High disconnection ‚Äî immediate containment':'Desconexi√≥n alta ‚Äî contenci√≥n inmediata');
  if (p <= 3.0) return (lang==='en'?'Medium disconnection ‚Äî prioritize 2‚Äì3 areas':'Desconexi√≥n media ‚Äî priorizar 2‚Äì3 √°reas');
  if (p <= 4.0) return (lang==='en'?'Moderate connection ‚Äî consolidate key habits':'Conexi√≥n moderada ‚Äî consolidar h√°bitos clave');
  return (lang==='en'?'Solid connection ‚Äî maintain cadence & metrics':'Conexi√≥n s√≥lida ‚Äî mantener cadencia y m√©tricas');
}

function interpretCosto(totalNum, lang){
  if (totalNum >= 100000) return (lang==='en'?'High annual leakage':'Fuga anual alta');
  if (totalNum >= 50000)  return (lang==='en'?'Moderate‚Äìhigh leakage':'Fuga moderada‚Äìalta');
  if (totalNum > 0)       return (lang==='en'?'Moderate leakage':'Fuga moderada');
  return (lang==='en'?'No leakage':'Sin fuga');
}

function interpretROI(recNum, lang){
  if (recNum <= 0) return (lang==='en'?'No recoverable potential detected':'Sin potencial recuperable detectado');
  return (lang==='en'
    ? 'Recoverable in ~12‚Äì18 months if prioritized'
    : 'Recuperable en ~12‚Äì18 meses si se prioriza');
}

// === Bloque ‚ÄúResumen ejecutivo‚Äù (Indicador | Valor | Interpretaci√≥n) ===
function drawExecutiveSummary(doc, {x, y, w, lang, nivelGeneral, promedioGeneral, costoTotalStr, recTotalNum}){
  const HROW = 20, PAD = 8;
  const cols = [ w*0.30, w*0.28, w*0.42 ];
  const y0 = y;

  // Encabezado
  doc.setFillColor(240,240,240);
  if (doc.roundedRect) doc.roundedRect(x, y, w, HROW, 6, 6, 'F');
  else doc.rect(x, y, w, HROW, 'F');
  doc.setFont('helvetica','bold'); doc.setFontSize(11);
  const HEADS = (lang==='en' ? ['Indicator','Value','Interpretation']
                              : ['Indicador','Valor','Interpretaci√≥n']);
  let cx = x + PAD, cy = y + 13;
  HEADS.forEach((h,i)=>{ doc.text(h, cx, cy); cx += cols[i]; });
  y += HROW;

  // Datos
  const costoNum = moneyToNumber(costoTotalStr);
  const filas = [
    [(lang==='en'?'General level':'Nivel general'), nivelGeneral, interpretNivel(nivelGeneral, lang)],
    [(lang==='en'?'Overall score':'Promedio general'), `${Number(promedioGeneral||0).toFixed(2)} / 5`, interpretPromedio(promedioGeneral, lang)],
    [(lang==='en'?'Total hidden cost':'Costo oculto total'), costoTotalStr, interpretCosto(costoNum, lang)],
    [(lang==='en'?'Recoverable (potential)':'Recuperable (potencial)'), fmtMoney(recTotalNum, lang), interpretROI(recTotalNum, lang)],
  ];

  // Filas
  filas.forEach(row=>{
    doc.setDrawColor(230); doc.line(x, y, x+w, y);
    // col 1 (label)
    let tx = x + PAD, ty = y + 13;
    doc.setFont('helvetica','bold'); doc.setFontSize(10); doc.text(row[0], tx, ty);
    // col 2 (valor)
    tx += cols[0]; doc.setFont('helvetica','normal'); doc.setFontSize(10); doc.text(row[1], tx, ty);
    // col 3 (interpretaci√≥n wrap)
    tx += cols[1];
    const wrap = doc.splitTextToSize(String(row[2]), cols[2]-PAD);
    doc.setFontSize(10.5);
    doc.text(wrap, tx, ty);
    const h = Math.max(HROW, 14 * wrap.length + 6);
    y += h;
  });

  // Marco
  if (doc.roundedRect) doc.roundedRect(x, y0, w, y - y0, 6, 6);
  else doc.rect(x, y0, w, y - y0);
  return y + GAP.lg;
}

/*function hardWrapLongTokens(s, max=28){
  return String(s).split(/\s/).map(tok=>{
    if (tok.length <= max) return tok;
    const parts=[]; for (let i=0;i<tok.length;i+=max) parts.push(tok.slice(i,i+max)+'-');
    parts[parts.length-1]=parts[parts.length-1].replace(/-$/,''); // quita guion final
    return parts.join(' ');
  }).join(' ');
}*/



// === P√°rrafos con buen interlineado/espaciado ===

function drawParagraph(doc, text, x, y, maxW, font='helvetica', style='normal', size=10.5, lineH=16, spaceAfter=GAP.md){
  doc.setFont(font, style); doc.setFontSize(size);

    const pageH  = doc.internal.pageSize.getHeight();
    const top    = 40;   // usa tu M_TOP si lo prefieres
    const bottom = 60;
    const yLimit = pageH - bottom;

  const lines = doc.splitTextToSize(String(text||''), maxW);
  
    for (const line of lines){
        if (y > yLimit){
        doc.addPage();
        if (doc.setTextColor) doc.setTextColor(0,0,0); // reasegura color
        doc.setFont(font, style); 
        doc.setFontSize(size);
        y = top;
        }
        doc.text(line, x, y);
        y += lineH;
    }
    return y + spaceAfter;
    

  //doc.text(lines, x, y);
  //return y + lines.length*lineH + spaceAfter;
}


function drawBoldLabelThenText(doc, label, text, x, y, maxW, gap = 6, size = 10, lineH = 12) {
  const pageH  = doc.internal.pageSize.getHeight();
  const top    = 40;   // usa tu M_TOP si prefieres
  const bottom = 60;
  const yLimit = pageH - bottom;

  const setBold = () => { doc.setFont('helvetica','bold');   doc.setFontSize(size); };
  const setBody = () => { doc.setFont('helvetica','normal'); doc.setFontSize(size); };
  const ensureInk = () => { if (doc.setTextColor) doc.setTextColor(0,0,0); };

  const br = () => {                // salto de p√°gina seguro
    doc.addPage();
    ensureInk();
    y = top;
  };

  const needsBreak = (h = lineH) => (y + h > yLimit);

  const safeText = String(text ?? '');
  const safeLabel = String(label ?? '');

  // 1) Si la etiqueta es demasiado ancha para compartir l√≠nea, la apilamos
  setBold();
  const labelW = doc.getTextWidth(safeLabel);
  const shareLine = (labelW + gap < maxW * 0.66); // heur√≠stica: cabe razonable

  if (!shareLine) {
    // (A) Imprime etiqueta sola en una l√≠nea
    if (needsBreak()) br();
    setBold(); doc.text(safeLabel, x, y); y += lineH;

    // (B) Imprime el cuerpo con paginaci√≥n l√≠nea por l√≠nea
    setBody();
    const lines = doc.splitTextToSize(safeText, maxW);
    for (const line of lines) {
      if (needsBreak()) br(), setBody();
      doc.text(line, x, y);
      y += lineH;
    }
    return y;
  }

  // 2) Etiqueta y primer trozo del cuerpo en la misma l√≠nea
  const firstLineW = Math.max(0, maxW - labelW - gap);
  setBody();
  const chunks = doc.splitTextToSize(safeText, firstLineW);
  const first = chunks.shift() || '';

  if (needsBreak()) br();
  setBold(); doc.text(safeLabel, x, y);
  setBody(); doc.text(first, x + labelW + gap, y);
  y += lineH;

  // 3) Resto del cuerpo, l√≠nea por l√≠nea con salto seguro
  for (const line of chunks) {
    if (needsBreak()) br(), setBody();
    doc.text(line, x, y);
    y += lineH;
  }

  return y;
}




// Helper: etiqueta en bold + texto normal con salto de l√≠nea correcto
/*function drawBoldLabelThenText(doc, label, text, x, y, maxW, gap = 6, size = 10, lineH = 12) {
  
  
  doc.setFont('helvetica','bold');  doc.setFontSize(size);
  const labelW = doc.getTextWidth(label);

  // Si la etiqueta cabe y deja espacio para texto en la misma l√≠nea
  const firstLineW = Math.max(0, maxW - labelW - gap);

  // Partimos el texto normal para la primera l√≠nea (resto va abajo)
  doc.setFont('helvetica','normal');
  const firstSlice = doc.splitTextToSize(text, firstLineW);
  const firstLineText = firstSlice.shift() || '';

  // Dibuja etiqueta + primer pedazo en la misma l√≠nea
  doc.setFont('helvetica','bold');
  doc.text(label, x, y);
  doc.setFont('helvetica','normal');
  doc.text(firstLineText, x + labelW + gap, y);

  // Dibuja el resto del texto, l√≠nea por l√≠nea, debajo
  let yy = y + lineH;
  firstSlice.forEach(line => {
    doc.text(line, x, yy);
    yy += lineH;
  });

  return yy; // devuelve el siguiente y disponible
}*/





// ‚Äî‚Äî‚Äî Normaliza el texto que viene del HTML (quita NBSPs y espacios finos) ‚Äî‚Äî‚Äî
function normalizeText(input){
  if (!input) return '';
  let t = String(input)
    .replace(/&nbsp;/gi, ' ')
    .replace(/[\u00A0\u202F]/g, ' ')
    .replace(/[\u2000-\u200B]/g, ' ')
    .replace(/\u00AD|\u2060|\ufeff/g, '')
    .replace(/[ \t]{2,}/g, ' ')
    .replace(/\n{3,}/g, '\n\n')
    .replace(/[‚Äú‚Äù]/g, '"')
    .replace(/[‚Äò‚Äô]/g, "'")
    .replace(/[‚Äì‚Äî]/g, '-')
    .replace(/\s+([.,;:!?‚Ä¶)\]\}])/g, '$1')
    .replace(/([(\[\{])\s+/g, '$1')
    .trim();

  // colapsa secuencias "l e t r a s" separadas
  t = t.replace(/\b((?:\p{L}\s){2,}\p{L})\b/gu, m => m.replace(/\s+/g, ''));
  t = t.replace(/\b((?:\p{N}\s){2,}\p{N})\b/gu, m => m.replace(/\s+/g, ''));

  // üîë aplica la limpieza de letras hu√©rfanas en todo el texto
  return stripDanglingInitials(t);
}



function renderAnalisisConNegritas(doc, text, x, y, maxW, opts = {}) {
  const { size = 10.5, lineH = 16, topMargin = 40, bottomMargin = 60 } = opts;

  const pageH = doc.internal.pageSize.getHeight();
  const yLimit = pageH - bottomMargin;

  const ensureInk = () => { if (doc.setTextColor) doc.setTextColor(0,0,0); };

  doc.setFont('helvetica','normal');
  doc.setFontSize(size);

  // 1) Normalizador para comillas/guiones (antes de los regex)
const QL = `[‚Äú"']`;   // abre
const QR = `[‚Äù"']`;   // cierra
const DASH = `[‚Äî‚Äì-]`;

// 2) √Åreas flexibles en EN: "&" o "and", Wellbeing / Well-being
const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const AREAS_ES = [
  'Prop√≥sito y estrategia',
  'Liderazgo y gobernanza',
  'Cultura y bienestar',
  'Aprendizaje e innovaci√≥n',
  'Procesos y tecnolog√≠a',
  'Sostenibilidad e impacto'
];
const AREAS_EN_RAW = [
  'Purpose & Strategy',
  'Leadership & Governance',
  'Culture & Wellbeing',
  'Learning & Innovation',
  'Processes & Technology',
  'Sustainability & Impact'
];
const toFlexibleEN = s => esc(s)
  .replace(/&/g, '\\s*(?:&|and)\\s*')
  .replace(/Wellbeing/g, 'Well[- ]?being');
const AREAS_EN_FLEX = AREAS_EN_RAW.map(toFlexibleEN);
const AREAS_ALT = [...AREAS_ES.map(esc), ...AREAS_EN_FLEX].join('|');

// 3) Patrones robustos
const AREA_RX = new RegExp(
  `^\\s*((?:En|In)\\s+(${AREAS_ALT}))\\s+${DASH}\\s+${QL}?([^‚Äù"']+)${QR}?\\.?\\s*(.*)$`,
  'u'
);
const OPORT_RX = new RegExp(
  `^\\s*(Oportunidades prioritarias\\.|Priority opportunities\\.)\\s*(.*)$`,
  'u'
);
const FORTC_RX = new RegExp(
  `^\\s*(Fortalezas clave\\.|Key strengths\\.)\\s*(.*)$`,
  'u'
);
const FORT_AREA_RX = new RegExp(
  `^\\s*(${AREAS_ALT})\\s+${DASH}\\s+${QL}?([^‚Äù"']+)${QR}?\\.?\\s*(.*)$`,
  'u'
);
const FORTL_RX = new RegExp(
  `^\\s*((?:Fortaleza|Strength)\\s+[‚Äì-]\\s+(${AREAS_ALT}))\\s+${DASH}\\s+${QL}?([^‚Äù"']+)${QR}?\\.?\\s*(.*)$`,
  'u'
);


  // ====== Helper para imprimir etiqueta en bold + cuerpo ======
  const drawBoldLine = (label, body) => {
    if (y > yLimit) { doc.addPage(); ensureInk(); y = topMargin; }
    doc.setFont('helvetica','bold');
    const labelW = doc.getTextWidth(label);
    const firstLineW = Math.max(0, maxW - labelW - 6);

    doc.setFont('helvetica','normal');
    const firstSlice = doc.splitTextToSize(String(body || ''), firstLineW);
    const firstLine = firstSlice.shift() || '';

    doc.setFont('helvetica','bold'); doc.text(label, x, y);
    doc.setFont('helvetica','normal'); doc.text(firstLine, x + labelW + 6, y);
    y += lineH;

    firstSlice.forEach(line => {
      if (y > yLimit) { doc.addPage(); ensureInk(); y = topMargin; }
      doc.text(line, x, y);
      y += lineH;
    });
    y += 8;
  };

  // ====== Renderizado p√°rrafo por p√°rrafo ======
  const paras = String(text).split(/\n\s*\n/);
  for (let p of paras) {
    p = p.trim();
    if (!p) { y += 8; continue; }

    // 1) Oportunidades prioritarias / Priority opportunities
    let m = p.match(OPORT_RX);
    if (m) { drawBoldLine(m[1], m[2]); continue; }

    // 2) En|In <√Årea> ‚Äî ‚Äú‚Ä¶‚Äù (en secciones de oportunidades)
    m = p.match(AREA_RX);
    if (m) {
      const etiqueta = `${m[1]} ‚Äî ‚Äú${m[3]}.‚Äù`;
      const cuerpo   = m[4] || '';
      drawBoldLine(etiqueta, cuerpo);
      continue;
    }

    // 3) Fortalezas clave / Key strengths
    m = p.match(FORTC_RX);
    if (m) { drawBoldLine(m[1], m[2]); continue; }

    // 4) <√Årea> ‚Äî ‚Äú‚Ä¶‚Äù (l√≠neas de fortalezas por √°rea)
    m = p.match(FORT_AREA_RX);
    if (m) {
      const etiqueta = `${m[1]} ‚Äî ‚Äú${m[2]}.‚Äù`;
      const cuerpo   = m[3] || '';
      drawBoldLine(etiqueta, cuerpo);
      continue;
    }

    // 5) (opcional) Fortaleza|Strength ‚Äì <√Årea> ‚Äî ‚Äú‚Ä¶‚Äù
    m = p.match(FORTL_RX);
    if (m) {
      const etiqueta = `${m[1]} ‚Äî ‚Äú${m[3]}.‚Äù`;
      const cuerpo   = m[4] || '';
      drawBoldLine(etiqueta, cuerpo);
      continue;
    }

    // 6) P√°rrafo normal
    const lines = doc.splitTextToSize(p, maxW);
    for (const line of lines) {
      if (y > yLimit) { doc.addPage(); ensureInk(); y = topMargin; }
      doc.text(line, x, y);
      y += lineH;
    }
    y += 8;
  }

  return y;
}

// === Detecci√≥n robusta del tipo de imagen seg√∫n el base64 (sin header) ===
function detectImageFormatFromBase64(b64){
  if (!b64) return null;
  const s = String(b64).trim().replace(/\s+/g,'');
  // JPEG t√≠picamente empieza con /9j/
  if (s.startsWith('/9j/')) return 'JPEG';
  // PNG t√≠picamente empieza con iVBORw0KGgo
  if (s.startsWith('iVBOR')) return 'PNG';
  return null;
}

// === Normaliza lo que venga (con o sin header) y devuelve {dataURL, fmt} ===
function toDataURLAndFormat(raw, hintedFmt){
  if (!raw) return { dataURL:null, fmt:null };

  let s = String(raw).trim();
  // Quita espacios y saltos que rompen el dataURL
  s = s.replace(/\s+/g,'');

  // Si ya viene como dataURL completo:
  if (/^data:image\/(png|jpe?g);base64,/i.test(s)){
    const fmt = /png/i.test(s) ? 'PNG' : 'JPEG';
    return { dataURL: s, fmt };
  }

  // Si viene "desnudo" (solo base64): detecta formato
  const fmt = (hintedFmt && (hintedFmt.toUpperCase()==='PNG' || hintedFmt.toUpperCase()==='JPEG'))
    ? hintedFmt.toUpperCase()
    : (detectImageFormatFromBase64(s) || 'JPEG'); // por defecto JPEG

  const prefix = (fmt === 'PNG')
    ? 'data:image/png;base64,'
    : 'data:image/jpeg;base64,';

  return { dataURL: prefix + s.replace(/^,+/, ''), fmt };
}





// 1. Avisar a Wix "ya estoy listo"
window.parent.postMessage({ type: 'ready' }, "*");

// 2. Escuchar datos desde Wix
window.addEventListener('message', async (event) => {
  const data = event.data;
  if (!data) return;

  // ignorar mensajes tipo "ready" que t√∫ mismo mandas
  if (data.type === 'ready') return;

  // s√≥lo reaccionar a data v√°lidos del diagn√≥stico
  if (data.type === 'datosInforme') {
  try {
    await generarPDFyDescargar(data); // genera y dentro ya env√≠a pdf-ok o pdf-url
    
    //window.parent.postMessage({ type:'pdf-ok' }, '*');
  } catch(err) {
    console.error('[PDF] Error generando PDF:', err);
    window.parent.postMessage({ type:'pdf-error', message: String(err && err.message || err) }, '*');
  }
 }
});





async function generarPDFyDescargar(data){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({
    unit: 'pt',   // puntos
    format: 'letter' // o 'a4', seg√∫n tu pdf original
  });
  if (doc.setLineHeightFactor) doc.setLineHeightFactor(1.35);

  // Validaciones suaves (no rompen el PDF; solo loguean)
    if (!data || typeof data !== 'object') {
    console.warn('[PDF] data vac√≠o/indefinido en generarPDFyDescargar');
    }
    if (!Array.isArray(data.areasDetalle)) {
    console.warn('[PDF] data.areasDetalle ausente o no es array');
    }
    if (data?.imagenes?.costos && typeof data?.imagenes?.costos !== 'string') {
    console.warn('[PDF] imagen de costos no es string/base64');
    }


  if (doc.setTextColor) doc.setTextColor(0,0,0);

  // Margenes b√°sicos
  const M_LEFT = 40;
  const M_TOP  = 40;
  let y = M_TOP;

  // ============ PORTADA / P√ÅGINA 1 ============

  // Branding arriba derecha
  /*doc.setFont('helvetica','normal');
  doc.setFontSize(8);
  doc.text('Innovaci√≥n Regenerativa | Informe diagn√≥stico', 400, y);
  y = bump(y, GAP.lg); */  
  


  // Logo arriba derecha (usa data.logoUrl)
await drawLogoTopRight(doc, data.logoUrl, { top: M_TOP - 6, right: 40, maxW: 60, maxH:60 });
// no movemos "y" porque el contenido va por la izquierda




  // T√≠tulo
  doc.setFontSize(16);
  doc.setFont('helvetica','bold');
  doc.text(
    data.idioma === 'en'
      ? 'ORGANIZATIONAL DIAGNOSTIC REPORT'
      : 'INFORME DIAGN√ìSTICO ORGANIZACIONAL',
    M_LEFT,
    y
  );
  y = bump(y, GAP.lg);       


  // Subt√≠tulo institucional
    doc.setFont('helvetica','bold');
    doc.setFontSize(14);
    doc.text('Innovaci√≥n Regenerativa', M_LEFT, y);
   y = bump(y, GAP.md);       // antes y += 20


  // Subt√≠tulo
  doc.setFontSize(11);
  doc.setFont('helvetica','normal');
  y += 4;
   doc.text(
    splitLines(
      doc,
      data.idioma === 'en'
        ? 'A starting point to align purpose, energy, and outcomes in your organization'
        : 'Un punto de partida para alinear prop√≥sito, energ√≠a y resultados en tu organizaci√≥n',
      520
    ),
    M_LEFT,
    y
  );
 y = bump(y, GAP.lg);


  // Bloque de datos del usuario/empresa

doc.setFontSize(10.5); // un poco m√°s grande
const labelFont = 'helvetica';
const valueFont = 'helvetica';

// L√≠nea 1: Nombre + Empresa
doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Name:' : 'Nombre:', M_LEFT, y);
doc.setFont(valueFont, 'normal');
doc.text(`${data.nombre} ${data.apellido}`, M_LEFT + 55, y);

doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Organization:' : 'Empresa:', M_LEFT + 220, y);
doc.setFont(valueFont, 'normal');
doc.text(data.empresa, M_LEFT + 300, y);
y = bump(y, GAP.lg);

// L√≠nea 2: Puesto + Pa√≠s
doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Role:' : 'Puesto:', M_LEFT, y);
doc.setFont(valueFont, 'normal');
doc.text(data.puesto, M_LEFT + 45, y);

doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Country:' : 'Pa√≠s:', M_LEFT + 220, y);
doc.setFont(valueFont, 'normal');
doc.text(data.pais || '', M_LEFT + 260, y);
y = bump(y, GAP.lg);

// L√≠nea 3: Fecha
doc.setFont(labelFont, 'bold');
doc.text(data.idioma === 'en' ? 'Date:' : 'Fecha:', M_LEFT, y);
doc.setFont(valueFont, 'normal');
doc.text(data.fecha, M_LEFT + 40, y);
y = bump(y, GAP.lg);



  // Frase inspiradora
  doc.setFont('helvetica','italic');
  doc.setFontSize(13);
  const frase = (data.idioma === 'en')
    ? 'We cannot impose regeneration; we can only create the conditions for it to emerge.'
    : 'No podemos imponer la regeneraci√≥n, solo podemos crear las condiciones para que emerja.';
  y = drawParagraph(doc, `"${frase}"`, M_LEFT, y, 520, "helvetica", "italic", 9.5, 12, 0);
  
  doc.setFont('helvetica','normal');
  doc.setFontSize(11);
  doc.text('Regenesis Group', M_LEFT, y + 8);
  y = bump(y, GAP.xl);


  // Bloque estado general
  doc.setFont('helvetica','bold');
  doc.setFontSize(12);
  doc.text(
    data.idioma === 'en'
      ? 'Organizational status'
      : 'Nivel general organizacional',
    M_LEFT, y
  );
  y = bump(y, GAP.md);


  

  // Insight / lectura humana
    doc.setFont('helvetica','normal');
    doc.setFontSize(10); // antes era 9
    const insight = data.insightNivel || '';
    //const insightLines = splitLines(doc, insight, 520);
    y = drawParagraph(doc, insight, M_LEFT, y, 520, 'helvetica', 'normal', 11, 16, GAP.sm);



    // ---- Caja gris de M√âTRICAS (Promedio, Nivel, Costo total, ROI/Recuperable) ----
    const lang = data.idioma === 'en' ? 'en' : 'es';

    // Si a√∫n no tienes ‚Äúrows‚Äù construidas aqu√≠, calcula el recuperable total a partir de las √°reas:
    const NOMBRES_ES = { proposito:'Prop√≥sito y estrategia', liderazgo:'Liderazgo y gobernanza', cultura:'Cultura y bienestar', aprendizaje:'Aprendizaje e innovaci√≥n', procesos:'Procesos y tecnolog√≠a', sostenibilidad:'Sostenibilidad e impacto' };
    const NOMBRES_EN = { proposito:'Purpose & Strategy', liderazgo:'Leadership & Governance', cultura:'Culture & Wellbeing', aprendizaje:'Learning & Innovation', procesos:'Processes & Technology', sostenibilidad:'Sustainability & Impact' };

    // Calcula recuperable total (ya lo ten√≠as)
    /*let recuperableTotalN = 0;
    (data.areasDetalle || []).forEach(a => {
    const avg = Number(a.promedio || 0);
    const costN = moneyToNumber(a.costoUSD);
    const rate  = recRateFromScore(avg);
    recuperableTotalN += Math.round(costN * rate);
    });*/


// ========= Helpers LOCALES para el an√°lisis dimensional (reutiliza NOMBRES_ES/EN) =========
function _wrap(doc, txt, maxW){
  return doc.splitTextToSize(String(txt ?? ''), maxW);
}
function _ensureSpace(doc, y, needH, top=40, bottom=60){
  const pageH = doc.internal.pageSize.getHeight();
  if (y + needH > pageH - bottom){
    doc.addPage();
    if (doc.setTextColor) doc.setTextColor(0,0,0);
    return top;
  }
  return y;
}



function _drawAreaDimBoxClosed(doc, {x, y, w, item, lang}) {
  const ROT = (lang==='en'
    ? { nivel:'Level:', urgencia:'Urgency:', consecuencia:'Consequence:', recomendacion:'Recommendation:' }
    : { nivel:'Nivel:', urgencia:'Urgencia:', consecuencia:'Consecuencia:', recomendacion:'Recomendaci√≥n:' }
  );
  const visible = (lang==='en' ? NOMBRES_EN[item.areaKey] : NOMBRES_ES[item.areaKey]) || item.areaKey;

  const y0 = y;
  doc.setFillColor(234,244,241);
  if (doc.roundedRect) doc.roundedRect(x, y, w, 12, 2, 2, 'F'); else doc.rect(x, y, w, 12, 'F');
  doc.setFont('helvetica','bold'); doc.setFontSize(10); doc.setTextColor(0);
  doc.text(String(visible).toUpperCase(), x+6, y+8);
  y += 18;

  const colX = x + 6;
  const colW = w - 12;

  // Nivel
  doc.setFont('helvetica','bold'); doc.setFontSize(9);
  doc.text(`${ROT.nivel} ${String(item.nivelLabel||'')} (${String(item.promedio||'0.0')}/5)`, colX, y);
  y += 14;

  // Urgencia
  doc.text(ROT.urgencia, colX, y);
  y += 12; doc.setFont('helvetica','normal'); doc.setFontSize(9.5);
  _wrap(doc, item.urgencia || '', colW).forEach(line => { doc.text(line, colX, y); y += 14; });

  // Consecuencia
  y += 8; doc.setFont('helvetica','bold'); doc.setFontSize(9);
  doc.text(ROT.consecuencia, colX, y);
  y += 12; doc.setFont('helvetica','normal'); doc.setFontSize(9.5);
  _wrap(doc, item.consecuencia || '', colW).forEach(line => { doc.text(line, colX, y); y += 14; });

  // Recomendaci√≥n
  y += 8; doc.setFont('helvetica','bold'); doc.setFontSize(9);
  doc.text(ROT.recomendacion, colX, y);
  y += 12; doc.setFont('helvetica','normal'); doc.setFontSize(9.5);
  _wrap(doc, item.recomendacion || '', colW).forEach(line => { doc.text(line, colX, y); y += 14; });

  // Marco
  doc.setDrawColor(210); doc.setLineWidth(0.4);
  if (doc.roundedRect) doc.roundedRect(x, y0, w, (y - y0) + 4, 2, 2);
  else doc.rect(x, y0, w, (y - y0) + 4);

  return y + 12; // siguiente y
}

function _renderAnalisisDimensional(doc, data, startY, left=40, totalW=520){
  const lang = (data.idioma==='en'?'en':'es');
  const titulo = (lang==='en' ? 'Dimensional analysis by area' : 'An√°lisis dimensional por √°rea');

  let y = _ensureSpace(doc, startY, 28); // por el t√≠tulo
  doc.setFont('helvetica','bold'); doc.setFontSize(12); doc.setTextColor(0);
  doc.text(titulo, left, y);
  y += 18;

  const colW = 250; // 2 columnas (250 + 20 de gutter + 250 = 520 aprox)
  const gutter = 20;
  const rightX = left + colW + gutter;

  const items = Array.isArray(data.areasDetalle) ? data.areasDetalle : [];
  let maxRowY = y;

  items.forEach((item, idx) => {
    const isLeft = (idx % 2 === 0);
    const x = isLeft ? left : rightX;

    // Altura estimada m√≠nima por caja para decidir salto (aprox 140‚Äì220)
    y = _ensureSpace(doc, y, 180);

    const nextY = _drawAreaDimBoxClosed(doc, {x, y, w: colW, item, lang});
    if (isLeft) {
      // dejamos y tal cual; comparamos al cerrar la fila
      maxRowY = Math.max(maxRowY, nextY);
    } else {
      // cerramos la fila y bajamos
      y = Math.max(maxRowY, nextY);
      maxRowY = y;
    }
  });

  // Si qued√≥ una √∫ltima caja en izquierda sin par, empuja y para no encimar lo siguiente
  if (items.length % 2 === 1) y = maxRowY + 6;

  return y + 6;
}

// ===== Resumen ejecutivo con interpretaci√≥n (antes de "Nivel general organizacional") =====

// Recuperable total (mismo c√°lculo que usas despu√©s)
    let recTotalNum = 0;
    (data.areasDetalle || []).forEach(a=>{
    const avg  = Number(a.promedio || 0);
    const cost = moneyToNumber(a.costoUSD);
    recTotalNum += Math.round(cost * recRateFromScore(avg));
    });

    {
  const pageH  = doc.internal.pageSize.getHeight();
  const bottom = 60;
  const needH  = 120; // alto m√≠nimo estimado del bloque
  if (y + needH > pageH - bottom) { doc.addPage(); if (doc.setTextColor) doc.setTextColor(0,0,0); y = M_TOP; }

  // marco de depuraci√≥n (temporal)
  //doc.setDrawColor(220); 
  //doc.rect(M_LEFT - 4, y, 520, 100); // caja de gu√≠a para ver d√≥nde cae el bloque
}


    // Dibuja el bloque
    y = drawExecutiveSummary(doc, {
    x: M_LEFT - 4,
    y,
    w: 520,
    lang: (data.idioma === 'en' ? 'en' : 'es'),
    nivelGeneral: data.nivelGeneral,
    promedioGeneral: data.promedioGeneral,   // <<‚Äî‚Äî NUEVO
    costoTotalStr: data.costoTotalUSD,
    recTotalNum
    });
   y = bump(y, GAP.xs);


    doc.setFontSize(11);
    const recoLabel = (data.idioma === 'en') ? 'Key recommendation:' : 'Recomendaci√≥n clave:';
    const recoBody  = (data.idioma === 'en')
    ? ' Focus leadership attention on the 2‚Äì3 lowest scoring areas and link fixes to strategic purpose. Disconnection is expensive ‚Äî and reversible.'
    : ' Poner en agenda de liderazgo las 2‚Äì3 √°reas con menor puntaje y vincular su mejora al prop√≥sito estrat√©gico. La desconexi√≥n es costosa, pero reversible.';

    // T√≠tulo ‚ÄúRecomendaci√≥n‚Äù no hace falta; imprime directamente la l√≠nea compuesta:
    doc.setFontSize(10);
    y = drawBoldLabelThenText(doc, recoLabel, recoBody, M_LEFT, y, 520, 6, 10, 12);
   y = bump(y, GAP.md);


  // Tabla resumen por dimensi√≥n
  doc.setFont('helvetica','bold');
  doc.setFontSize(11);
  doc.text(
    data.idioma==='en'
      ? 'Results by dimension'
      : 'Resultados por dimensi√≥n',
    M_LEFT,
    y
  );
  y = bump(y, GAP.md);


  // ===== Construcci√≥n de filas para la tabla (usa data.areasDetalle ya enviado desde Velo) =====
   

    // Normalizamos filas con ROI
    const rows = (data.areasDetalle || []).map(a => {
    const label = (lang==='en' ? NOMBRES_EN[a.areaKey] : NOMBRES_ES[a.areaKey]) || a.areaKey;
    const avg   = Number(a.promedio || 0);
    const costN = moneyToNumber(a.costoUSD);             // n√∫mero
    const rate  = recRateFromScore(avg);                 // 0.70 / 0.60 / 0.45 / 0.30
    const rec   = Math.round(costN * rate);              // recuperable potencial
    const inv   = Math.max(1, Math.round(rec / (CONFIG_ROI.roiMultipleMin||5))); // inversi√≥n estimada p/‚â•5x
    const roiX  = (rec>0 && inv>0) ? (rec/inv) : CONFIG_ROI.roiMultipleMin;

    return {
        name: label,
        avg: avg.toFixed(1),
        costStr: fmtMoney(costN, lang),                // "$16,800 USD"
        roiStr: fmtMoney(rec, lang)    // solo el monto recuperable potencial
        // si prefieres explicitar inversi√≥n: `${fmtMoney(rec, lang)} (inv. ~${fmtMoney(inv, lang)} ‚Üí ‚â•${CONFIG_ROI.roiMultipleMin}x)`
    };
    });

    // Dibujar tabla
    y = drawResultsTable(doc, { lang, x: M_LEFT, y, w: 520 }, rows);

    // === Bloque final: Costo oculto + Recuperable (mantener juntas) ===
    const totalLinea = (
    lang==='en'
        ? `Estimated hidden cost: ${data.costoTotalUSD} per year.`
        : `Costo oculto estimado: ${data.costoTotalUSD} al a√±o.`
    );

    const recBlockNum = rows.reduce((acc, r) => acc + moneyToNumber(r.roiStr), 0); // ya lo calculaste arriba; usa ese si lo prefieres
    const recLinea = (
    lang==='en'
        ? `Recoverable (potential): ${fmtMoney(recBlockNum, lang)}.`
        : `Recuperable (potencial): ${fmtMoney(recBlockNum, lang)}.`
    );

    // Medimos l√≠neas para evitar corte
    doc.setFont('helvetica','bold'); doc.setFontSize(10);
    const l1 = doc.splitTextToSize(totalLinea, 520);
    const l2 = doc.splitTextToSize(recLinea, 520);
    const pageH2 = doc.internal.pageSize.getHeight();
    const bottom = 60;
    const needH = l1.length*12 + l2.length*12 + 10; // 10pt de separaci√≥n interna

    if (y + needH > pageH2 - bottom) {
    doc.addPage();
    if (doc.setTextColor) doc.setTextColor(0,0,0);
    y = M_TOP;
    }

    // Imprime bloque
    l1.forEach(line => { doc.text(line, M_LEFT, y); y += 12; });
    y += 4; // separaci√≥n corta
    l2.forEach(line => { doc.text(line, M_LEFT, y); y += 12; });
    y += 8; // peque√±o margen despu√©s del bloque




  // ============ P√ÅGINA 2: Retos / Fortalezas / Acciones clave ============
  doc.addPage();
  await drawLogoTopRight(doc, data.logoUrl, { top: M_TOP - 6, right: 40, maxW: 60, maxH:60 });
  y = M_TOP;
  y += 40;

 

  // üîí Forzar espaciados a 0
//if (doc.setCharSpace)  doc.setCharSpace(0);
//if (doc.setWordSpace)  doc.setWordSpace(0);  // algunas builds lo exponen
// (opcional) doc.setGState(new doc.GState({ charSpace: 0, wordSpace: 0 })); // si tu build lo permite

    const resumenLimpio = stripDanglingInitials(
    normalizeText(
        limpiarHTML(data.analisisNivel)
    )
    );



  doc.setFont('helvetica','bold');
  doc.setFontSize(12);
  doc.text(
    data.idioma==='en'
      ? 'Priority tensions and opportunities'
      : 'Tensiones prioritarias y oportunidades',
    M_LEFT, y
  );
  y+=26;

    // t√≠tulo ya lo dejaste puesto arriba; ahora el cuerpo:
    y = renderAnalisisConNegritas(doc, resumenLimpio, M_LEFT, y, 520, {
  size: 10.5, lineH: 16, topMargin: M_TOP, bottomMargin: 60
   });




   // === NUEVA P√ÅGINA 3: Gr√°fica de Costos & ROI ===
        doc.addPage();
        const logoH3 = await drawLogoTopRight(doc, data.logoUrl, { top: M_TOP - 6, right: 40, maxW: 60, maxH: 60 });

        // Punto de arranque para el t√≠tulo de la gr√°fica: top + alto del logo + margen
        y = M_TOP + (logoH3 || 0) + GAP.md;   // p.ej. GAP.md = 18pt

       

        if (doc.setTextColor) doc.setTextColor(0,0,0);
        
        y = drawCostChartIfAny(doc, data, M_LEFT, y, 520);
        y = bump(y, GAP.md);    // margen inferior despu√©s de la imagen


        // ‚Äî‚Äî‚Äî P√°rrafo explicativo de la gr√°fica (si viene) ‚Äî‚Äî‚Äî
    if (data.graficaCostosExplicacion) {
    // Normaliza por si llega con saltos / espacios raros
    const textoGraf = stripDanglingInitials(
        normalizeText(String(data.graficaCostosExplicacion))
    );


    doc.setFont('helvetica','bold'); doc.setFontSize(12);
    doc.text(
        data.idioma === 'en'
        ? 'Hidden costs and recovery potential by key area'
        : 'Costo oculto y potencial de recuperaci√≥n por √°rea clave',
        40, y
    );
    y += 18;

    y = drawParagraph(
        doc,
        textoGraf,
        40,          // margen izquierdo
        y,
        520,         // ancho de texto
        'helvetica',
        'normal',
        10.5,        // tama√±o
        16,          // interlineado
        12           // espacio despu√©s
    );
    }

    // === NUEVA P√ÅGINA 4: Gr√°fica de Tensi√≥n por √Årea ===
    doc.addPage();
    const logoH4 = await drawLogoTopRight(doc, data.logoUrl, { top: M_TOP - 6, right: 40, maxW: 60, maxH: 60 });

    y = M_TOP + (logoH4 || 0) + GAP.md;
    if (doc.setTextColor) doc.setTextColor(0,0,0);
    y = drawAreasChartIfAny(doc, data, M_LEFT, y, 520);
    y = bump(y, GAP.md);

    // ‚Äî‚Äî‚Äî Texto explicativo de la desconexi√≥n (mismo que en la web) ‚Äî‚Äî‚Äî
    {
      const textoDesc =  (data.graficaDesconexionExplicacion && String(data.graficaDesconexionExplicacion)) ||
    (data.introDesconexion && String(data.introDesconexion)) ||
    (data.insightNivel && String(data.insightNivel)) ||
    '';
      if (textoDesc) {
        const limpio = stripDanglingInitials(normalizeText(textoDesc));

        doc.setFont('helvetica','bold'); 
        doc.setFontSize(12);
        doc.text(
          data.idioma === 'en' 
            ? 'Human tension and critical organization areas' 
            : 'Tensi√≥n humana y √°reas cr√≠ticas',
          M_LEFT, y
        );
        y += 18;

        y = drawParagraph(
          doc,
          limpio,
          M_LEFT,           // margen izquierdo
          y,
          520,              // ancho de texto
          'helvetica',
          'normal',
          10.5,             // tama√±o
          16,               // interlineado
          GAP.md            // espacio despu√©s
        );
      }
    }


    // ============ P√ÅGINA 5: An√°lisis dimensional por √°rea ============
    doc.addPage();
    const logoH5 = await drawLogoTopRight(doc, data.logoUrl, { top: M_TOP - 6, right: 40, maxW: 60, maxH: 60 });

        // Punto de arranque para el t√≠tulo de la gr√°fica: top + alto del logo + margen
        y = M_TOP + (logoH5 || 0) + GAP.md;   // p.ej. GAP.md = 18pt
    
        let yDim = M_TOP;
    
        yDim = _renderAnalisisDimensional(doc, data, yDim, M_LEFT, 520);

      


  // descarga
  const fileName = generarNombreArchivo(data);
  try {
  // Primer intento: descarga directa
  doc.save(fileName);
  // Aviso de √©xito (ya lo mandas arriba, lo dejamos por compatibilidad)
        window.parent.postMessage({ type:'pdf-ok' }, '*');
        } catch(e) {
        // Fallback: enviar bloburl al parent para forzar descarga desde el contexto principal
        const href = doc.output('bloburl');
        window.parent.postMessage({ type:'pdf-url', href, filename: fileName }, '*');
        }
}

// Helpers para formatear texto:
function splitLines(doc, text, maxWidth){
  if (!text) return [''];
  // jsPDF 2.5: splitTextToSize
  return doc.splitTextToSize(String(text), maxWidth);
}

function limpiarHTML(htmlString){
  if (!htmlString) return '';
  return String(htmlString)
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n\n')
    // Elimina inline tags SIN insertar espacios que queden flotando
    .replace(/<\/?(strong|em|b|i|u|span)\b[^>]*>/gi, '')
    // Elimina el resto de etiquetas
    .replace(/<[^>]+>/g, '')

    .replace(/[\u2000-\u200D\u2060\ufeff]/g, '')
    // Sustitutos seguros
    .replace(/&nbsp;/gi, ' ')
    .replace(/[ \t]{2,}/g, ' ')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

function stripDanglingInitials(s){
  // quita letra hu√©rfana al inicio de l√≠nea O tras punto/salto
  return String(s)
    // inicio de l√≠nea
    .replace(/(^|\n)\s*[A-Za-z√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±]\s+(?=\p{L})/gu, '$1')
    // despu√©s de punto o dos puntos
    .replace(/([.:])\s*[A-Za-z√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±]\s+(?=\p{L})/gu, '$1 ');
}


function drawCostChartIfAny(doc, data, x, y, maxWidthPT) {
  try {
    const raw     = data?.imagenes?.costos || '';
    const hinted  = data?.imagenes?.costosFmt || null; // si no lo mandas, no pasa nada
    const srcW    = Number(data?.imagenes?.costosW || 0) || 1644;
    const srcH    = Number(data?.imagenes?.costosH || 0) || 1024;

    const { dataURL, fmt } = toDataURLAndFormat(raw, hinted);
    let finalFmt = fmt;
    if (!finalFmt) {
    const s = (raw||'').trim().replace(/\s+/g,'');
    finalFmt = s.startsWith('iVBOR') ? 'PNG' : (s.startsWith('/9j/') ? 'JPEG' : 'JPEG');
    }


    if (!dataURL) return y; // nada que dibujar

    const pageW  = doc.internal.pageSize.getWidth();
    const pageH  = doc.internal.pageSize.getHeight();
    const bottom = 60;

    const drawW  = Math.min(maxWidthPT, pageW - x - 40);
    const aspect = (srcW > 0 && srcH > 0) ? (srcH/srcW) : (9/16);
    const drawH  = Math.round(drawW * aspect);

    // Reservas (t√≠tulo + imagen + nota)
    const titulo = (data?.idioma === 'en')
      ? 'Hidden Costs & Recoverable ROI'
      : 'Costos ocultos & ROI recuperable';

    const note   = (data?.idioma === 'en')
      ? 'Bars: hidden cost by dimension ¬∑ Line: realistically recoverable portion (12‚Äì18 months).'
      : 'Barras: costo oculto por dimensi√≥n ¬∑ L√≠nea: porcentaje recuperable (12‚Äì18 meses).';

    doc.setFont('helvetica','bold'); doc.setFontSize(13);
    const noteLines = doc.splitTextToSize(note, drawW);
    const needH = 20 + drawH + (noteLines.length*12 + 6) + 6;

    if (y + needH > pageH - bottom){
      doc.addPage();
      if (doc.setTextColor) doc.setTextColor(0,0,0);
      y = 40;
    }

    // T√≠tulo
    doc.text(titulo, x, y);
    y += 20;

    // Imagen (usa el fmt REAL)
    //doc.addImage(dataURL, finalFmt, x, y, drawW, drawH);
    doc.addImage(dataURL, (finalFmt === 'PNG' ? 'PNG' : 'JPEG'), x, y, drawW, drawH);
    //doc.addImage(dataURL, fmt || 'JPEG', x, y, drawW, drawH);
    y += drawH + 10;

    // Nota
    doc.setFont('helvetica','normal'); doc.setFontSize(10);
    doc.text(noteLines, x, y);
    y += (noteLines.length*12 + 6);

    return y;
  } catch (e) {
    console.warn('[PDF] Error al dibujar gr√°fica de costos:', e);
    return y;
  }
}

function drawAreasChartIfAny(doc, data, x, y, maxWidthPT) {
  try {
    const raw     = data?.imagenes?.desconexion || '';
    const hinted  = data?.imagenes?.desconexionFmt || null;
    const srcW    = Number(data?.imagenes?.desconexionW || 0) || 1644;
    const srcH    = Number(data?.imagenes?.desconexionH || 0) || 1024;

    const { dataURL, fmt } = toDataURLAndFormat(raw, hinted);
    let finalFmt = fmt;
    if (!finalFmt) {
      const s = (raw||'').trim().replace(/\s+/g,'');
      finalFmt = s.startsWith('iVBOR') ? 'PNG' : (s.startsWith('/9j/') ? 'JPEG' : 'JPEG');
    }
    if (!dataURL) return y;

    const pageW  = doc.internal.pageSize.getWidth();
    const pageH  = doc.internal.pageSize.getHeight();
    const bottom = 60;

    const drawW  = Math.min(maxWidthPT, pageW - x - 40);
    const aspect = (srcW > 0 && srcH > 0) ? (srcH/srcW) : (9/16);
    const drawH  = Math.round(drawW * aspect);

    // T√≠tulo y nota
    const titulo = (data?.idioma === 'en')
      ? 'Human tension by area'
      : 'Tensi√≥n humana por √°rea';

    const note   = (data?.idioma === 'en')
      ? 'Bars: unmet capacity (0‚Äì4). Higher bar = more human tension.'
      : 'Barras: capacidad no instalada (0‚Äì4). Barra m√°s alta = mayor tensi√≥n humana.';

    doc.setFont('helvetica','bold'); doc.setFontSize(13);
    const noteLines = doc.splitTextToSize(note, drawW);
    const needH = 20 + drawH + (noteLines.length*12 + 6) + 6;

    if (y + needH > pageH - bottom){
      doc.addPage();
      if (doc.setTextColor) doc.setTextColor(0,0,0);
      y = 40;
    }

    // T√≠tulo
    doc.text(titulo, x, y);
    y += 20;

    // Imagen
    doc.addImage(dataURL, (finalFmt === 'PNG' ? 'PNG' : 'JPEG'), x, y, drawW, drawH);
    y += drawH + 10;

    // Nota
    doc.setFont('helvetica','normal'); doc.setFontSize(10);
    doc.text(noteLines, x, y);
    y += (noteLines.length*12 + 6);

    return y;
  } catch (e) {
    console.warn('[PDF] Error al dibujar gr√°fica de √°reas:', e);
    return y;
  }
}





// Genera nombre de archivo final
function generarNombreArchivo(data){
  const nom   = (data.nombre  || '').trim().replace(/\s+/g,'_');
  const emp   = (data.empresa || '').trim().replace(/\s+/g,'_');
  const fecha = (data.fecha   || '').replace(/[^\d-]/g,'_');
  return `Diagnostico_${nom}_${emp}_${fecha}.pdf`;
}
</script>
</body>
</html>